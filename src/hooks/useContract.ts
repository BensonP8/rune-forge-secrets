import { useWriteContract, useReadContract, useAccount } from 'wagmi';
import { useState, useCallback } from 'react';
import { contractAddresses } from '../lib/wallet-config';
import { encryptCraftingData, generateCraftingSession } from '../lib/fhe-utils';

// Contract ABI for RuneForgeSecrets
const CONTRACT_ABI = [
  {
    "inputs": [
      {"internalType": "uint256", "name": "_recipeId", "type": "uint256"},
      {"internalType": "bytes", "name": "_manaAmount", "type": "bytes"},
      {"internalType": "bytes", "name": "inputProof", "type": "bytes"}
    ],
    "name": "startCraftingSession",
    "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"internalType": "uint256", "name": "_sessionId", "type": "uint256"},
      {"internalType": "bytes", "name": "_successRate", "type": "bytes"},
      {"internalType": "bytes", "name": "inputProof", "type": "bytes"}
    ],
    "name": "completeCraftingSession",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "string", "name": "_name", "type": "string"}],
    "name": "registerCrafter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [{"internalType": "address", "name": "_crafter", "type": "address"}],
    "name": "getCrafterProfile",
    "outputs": [
      {"internalType": "string", "name": "name", "type": "string"},
      {"internalType": "uint8", "name": "level", "type": "uint8"},
      {"internalType": "uint8", "name": "experience", "type": "uint8"},
      {"internalType": "uint8", "name": "totalCrafts", "type": "uint8"},
      {"internalType": "uint8", "name": "successfulCrafts", "type": "uint8"},
      {"internalType": "uint8", "name": "reputation", "type": "uint8"},
      {"internalType": "bool", "name": "isActive", "type": "bool"},
      {"internalType": "uint256", "name": "joinedAt", "type": "uint256"}
    ],
    "stateMutability": "view",
    "type": "function"
  }
] as const;

export const useCraftingContract = () => {
  const { address } = useAccount();
  const { writeContract, isPending, error } = useWriteContract();
  const [currentSession, setCurrentSession] = useState<{
    sessionId: number | null;
    recipeId: number | null;
    startTime: number | null;
  }>({
    sessionId: null,
    recipeId: null,
    startTime: null,
  });

  // Register crafter
  const registerCrafter = useCallback(async (name: string) => {
    if (!address) throw new Error('Wallet not connected');
    
    try {
      await writeContract({
        address: contractAddresses.runeForgeSecrets as `0x${string}`,
        abi: CONTRACT_ABI,
        functionName: 'registerCrafter',
        args: [name],
      });
    } catch (err) {
      console.error('Failed to register crafter:', err);
      throw err;
    }
  }, [address, writeContract]);

  // Start crafting session
  const startCraftingSession = useCallback(async (recipeId: number) => {
    if (!address) throw new Error('Wallet not connected');
    
    try {
      // Generate crafting session data
      const sessionData = await generateCraftingSession(recipeId);
      
      // Encrypt the mana amount
      const encryptedMana = await encryptCraftingData({
        recipeId: sessionData.recipeId,
        difficulty: sessionData.difficulty,
        manaCost: sessionData.manaCost,
        successRate: sessionData.successRate,
      });
      
      // Create a mock proof (in real implementation, this would be generated by FHE SDK)
      const mockProof = '0x' + '0'.repeat(128);
      
      const result = await writeContract({
        address: contractAddresses.runeForgeSecrets as `0x${string}`,
        abi: CONTRACT_ABI,
        functionName: 'startCraftingSession',
        args: [recipeId, encryptedMana.manaCost, mockProof],
      });
      
      // Store session info locally
      setCurrentSession({
        sessionId: Date.now(), // Mock session ID
        recipeId,
        startTime: Date.now(),
      });
      
      return {
        sessionId: Date.now(),
        sessionData,
        encryptedData: encryptedMana,
      };
    } catch (err) {
      console.error('Failed to start crafting session:', err);
      throw err;
    }
  }, [address, writeContract]);

  // Complete crafting session
  const completeCraftingSession = useCallback(async (sessionId: number, successRate: number) => {
    if (!address) throw new Error('Wallet not connected');
    
    try {
      // Encrypt the success rate
      const encryptedSuccessRate = await encryptCraftingData({
        recipeId: 0,
        difficulty: 0,
        manaCost: 0,
        successRate,
      });
      
      // Create a mock proof
      const mockProof = '0x' + '0'.repeat(128);
      
      await writeContract({
        address: contractAddresses.runeForgeSecrets as `0x${string}`,
        abi: CONTRACT_ABI,
        functionName: 'completeCraftingSession',
        args: [sessionId, encryptedSuccessRate.successRate, mockProof],
      });
      
      // Clear current session
      setCurrentSession({
        sessionId: null,
        recipeId: null,
        startTime: null,
      });
      
      return true;
    } catch (err) {
      console.error('Failed to complete crafting session:', err);
      throw err;
    }
  }, [address, writeContract]);

  return {
    registerCrafter,
    startCraftingSession,
    completeCraftingSession,
    currentSession,
    isPending,
    error,
  };
};

// Hook to get crafter profile
export const useCrafterProfile = (crafterAddress?: string) => {
  const { address } = useAccount();
  const targetAddress = crafterAddress || address;
  
  const { data: profile, isLoading, error } = useReadContract({
    address: contractAddresses.runeForgeSecrets as `0x${string}`,
    abi: CONTRACT_ABI,
    functionName: 'getCrafterProfile',
    args: targetAddress ? [targetAddress] : undefined,
    query: {
      enabled: !!targetAddress,
    },
  });

  return {
    profile,
    isLoading,
    error,
  };
};
